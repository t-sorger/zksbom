use crate::config::load_config;
use rusqlite::{Connection, params};
use log::{debug, info, error};
use std::path::Path;
use std::fs;

/// Represents a Vulnerability entry
#[derive(Debug)]
pub struct VulnerabilityDbEntry {
    pub vulnerabilities: String,
    pub commitment: String,
}

pub fn init_db_vulnerability() {
    debug!("Initializing the vulnerability database...");
    let config = load_config().unwrap();
    let db_path = config.db_vulnerability.path;

    // Check if the directory exists, and create it if not
    let db_path_obj = Path::new(&db_path);
    if let Some(parent) = db_path_obj.parent() {
        if !parent.exists() {
            debug!("Creating directory for database: {}", parent.display());
            if let Err(e) = fs::create_dir_all(parent) {
                error!("Error creating database directory: {}", e);
                return; // Stop initialization if directory creation fails
            } else {
                info!("Database directory created.");
            }
        }
    }

    // Create the Vulnerability table if it doesn't exist
    match Connection::open(&db_path) {
        Ok(conn) => {
            if let Err(e) = conn.execute(
                "CREATE TABLE IF NOT EXISTS vulnerability (
                    vulnerabilities TEXT NOT NULL,
                    commitment TEXT NOT NULL,
                    PRIMARY KEY (commitment)
                )",
                [],
            ) {
                error!("Error initializing Vulnerability database: {}", e);
            } else {
                info!("Vulnerability database initialized.");
            }
        }
        Err(e) => error!("Error opening database connection: {}", e),
    };
}

fn get_db_vulnerability_conneciton() -> Connection {
    debug!("Getting the vulnerability database connection...");
    let config = load_config().unwrap();
    let db_path = config.db_vulnerability.path;

    match Connection::open(&db_path) {
        Ok(conn) => {
            info!("Vulnerability database connection established.");
            conn
        }
        Err(e) => {
            panic!("Error opening database connection: {}", e);
        }
    }
}

pub fn insert_vulnerability(vulnerability: VulnerabilityDbEntry) {
    debug!("Inserting vulnerability into the database...");
    let conn = get_db_vulnerability_conneciton();

    if let Err(e) = conn.execute(
        "INSERT INTO vulnerability (vulnerabilities, commitment) VALUES (?1, ?2)",
        params![vulnerability.vulnerabilities, vulnerability.commitment],
    ) {
        error!("Error inserting vulnerability into the database: {}", e);
    } else {
        info!("Vulnerability inserted into the database.");
    }
}

pub fn get_vulnerabilities(commitment: String) -> Result<VulnerabilityDbEntry, rusqlite::Error> {
    debug!("Getting vulnerability from the database...");
    let conn = get_db_vulnerability_conneciton();

    conn.query_row(
        "SELECT vulnerabilities, commitment FROM vulnerability WHERE commitment = ?1", // Corrected table name
        params![commitment],
        |row| {
            Ok(VulnerabilityDbEntry {
                vulnerabilities: row.get(0)?,
                commitment: row.get(1)?,
            })
        },
    )
}


pub fn delete_db_vulnerability() {
    debug!("Deleting the vulnerability database...");
    let conn = get_db_vulnerability_conneciton();
    if let Err(e) = conn.execute("DELETE FROM vulnerability", []) {
         error!("Error deleting vulnerability from the database: {}", e);
    }
}